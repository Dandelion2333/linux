Linux五种IO模型介绍：
同步阻塞模型
	1. 概念：应用进程进行系统调用时，内核准备数据与处理数据两个阶段，前者都被阻塞
	2. 流程图：
	3. 特点
		1. blocking IO在执行的两个阶段都被阻塞
	4. 优点：
		1. 响应及时，无延迟
	3. 缺点：
		1. 应用进程被阻塞导致工作效率变低

同步非阻塞模型
	1. 概念：应用进程进行系统调用时，内核准备数据阶段可以自己的事情，数据处理阶段被阻塞
	2. 流程图
	3. 特点
		1. 内核在准备数据阶段，应用进程需要每隔一段时间recvfrom一次（轮询），询问内核使用准备好数据
		2. 与blocking不同的点在于，除了轮询之外的时间，应用进程可以干自己的事。
		3. 在数据处理阶段，引用进程被阻塞。
	4. 优点
		1. 提高了应用进程的利用率。不用被一直阻塞（干等）
	5. 缺点
		1. 相对于blocking响应时间被降低。因为数据可能在应用进程未轮询时准备好。（例如100ms轮询一次），那么就可能延迟0-100ms的时间响应
	 
多路复用IO
	1. 概念：此模型应用select、poll、epoll函数。select可以监视多个任务进程（这些进程请求了系统调用）。当某个任务进程的数据准备好了后（不需要全部准备好，准备好了一部分数据即可），select就会通知该进程，并阻塞，然后执行数据处理（相当于边准备数据边把数据从内核复制用户空间）。
	2. 问题：准备数据阶段，应用进程是否被阻塞。有些地方讲调用了select后即被阻塞，有些地方则说不会被阻塞。此处待进一步确认。
		经查阅资料，用户进程主动等待并调用select函数获取就绪消息，并且其就绪进程状态为阻塞。从这句话中可以知道，用户进程是通过调用select函数后才能知道准备数据是否就绪。而调用select函数就一定会阻塞。
	3. 流程图：
	4. 特点
		1. 相对于non-blocking模型，IO多路复用不需要一直询问数据是否准备好了。而是使用select监控。
		2. 优点
	5. select可以监控多个任务。相比于多个任务都使用non-blocking会大大减少系统的开销。
		2. 提高了CPU的利用率
	6. 缺点
		1. 无
	7. 扩展：
		1. select
		2. poll
		3. epoll

信号驱动式IO
	1. 概念：应用进程进行系统调用时，内核回复一个信号处理程序。此时，应用程序就可以做自己的事情了。此处与non-blocking相同。当内核准备好数据后会主动发送一个SIGIO信号给应用进程函数，通知后者进行数据处理。
	2. 流程图
	3. 特点
		1. 等待数据阶段不需要像blocking阻塞。也不需要像non-blocking轮询数据是否准备好（因为轮询需要消耗大量的资源）。
		2. 数据处理阶段会被阻塞
	4. 优点
		1. 提高应用进程的工作效率，不需要阻塞也不需要轮询
	5. 缺点
		1. 无

异步非阻塞IO
	1. 概念：应用进程调用recvform后，内核返回（类似于告知前者，我收到你的指令了），内核准备好数据之后，会直接复制数据到用户空间（应用进程的空间），这两个操作应用进程都不被阻塞。然后内核通过消息发送给应用进程，告知数据已经妥当。
	2. 流程图
	3. 特点
		1. 应用程序进行系统调用后就不用管了（去忙自己的事情了），直到内核把数据准备好，并且送到它家里。
		2. 两个阶段（准备数据，拷贝数据），都不需要应用进程参与。
	4. 优点
		1. 应用程序执行效率最高（相对于其他IO模型）。
	5. 缺点
		1. 相对于blocking而言响应慢了点。

五种IO模型总结
	1. 流程图
	2. 


